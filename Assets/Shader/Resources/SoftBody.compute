// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PreSolve
#pragma kernel SolveElement

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture
RWStructuredBuffer<float3> corr;
RWStructuredBuffer<float3> pos;
RWStructuredBuffer<float3> prevPos;
RWStructuredBuffer<float3> vel;

StructuredBuffer<float> invMass;
StructuredBuffer<int4> tets;
StructuredBuffer<float> restVolumes;
StructuredBuffer<float3x3> invDm;
StructuredBuffer<int> elements;

uint verticesNum;
uint tetsNum;
uint passSize;
uint firstConstraint;

float dt;
float mu;
float lambda;
float3 gravity;

float3x3 GetDeformationGradient(uint tetId)
{
    int id0 = tets[tetId].x;
    int id1 = tets[tetId].y;
    int id2 = tets[tetId].z;
    int id3 = tets[tetId].w;
    
    float3x3 Ds = 0;
    Ds._m00_m10_m20 = pos[id1] - pos[id0];
    Ds._m01_m11_m21 = pos[id2] - pos[id0];
    Ds._m02_m12_m22 = pos[id3] - pos[id0];

    return mul(Ds, invDm[tetId]);
}
void ApplyToElement(uint i, float C, float compliance, float3x4 gradients)
{
    if (C == 0.0)
        return;

    float weight = 0.0;
    int id0 = tets[i].x;
    int id1 = tets[i].y;
    int id2 = tets[i].z;
    int id3 = tets[i].w;

    weight += dot(gradients._m00_m10_m20, gradients._m00_m10_m20) * invMass[id0];
    weight += dot(gradients._m01_m11_m21, gradients._m01_m11_m21) * invMass[id1];
    weight += dot(gradients._m02_m12_m22, gradients._m02_m12_m22) * invMass[id2];
    weight += dot(gradients._m03_m13_m23, gradients._m03_m13_m23) * invMass[id3];

    if (weight <= 0.0)
        return;

    float h2 = dt * dt;
    float alpha = compliance / h2 / restVolumes[i];
    float dlambda = -C / (weight + alpha);

    pos[id0] += dlambda * invMass[id0] * gradients._m00_m10_m20;
    pos[id1] += dlambda * invMass[id1] * gradients._m01_m11_m21;
    pos[id2] += dlambda * invMass[id2] * gradients._m02_m12_m22;
    pos[id3] += dlambda * invMass[id3] * gradients._m03_m13_m23;

}

[numthreads(64,1,1)]
void PreSolve(uint3 dispatchID : SV_DispatchThreadID)
{
    uint i = dispatchID.x;

    if(i >= verticesNum)
        return;

    corr[i] = 0;

    if(invMass[i] == 0)
        return;

    vel[i] += dt * gravity;

    prevPos[i] = pos[i];

    pos[i] += dt * vel[i];
}

[numthreads(64,1,1)]
void SolveElement(uint3 dispatchID : SV_DispatchThreadID)
{
    //if(dispatchID.x == 0)
    //{
    //    test[0] = 0;
    //    test[0] = GetDeformationGradient(0);
    //}
    //return;

     

    if(dispatchID.x >= passSize)
        return;

    uint tetId = elements[dispatchID.x + firstConstraint];

	float compliance = 1.0 / mu;

    float3x3 F = GetDeformationGradient(tetId);

    float f1 = dot(F._m00_m10_m20, F._m00_m10_m20);
    float f2 = dot(F._m01_m11_m21, F._m01_m11_m21);
    float f3 = dot(F._m02_m12_m22, F._m02_m12_m22);
    float r_s = sqrt(f1 + f2 + f3);
    float C = r_s;

    float r_s_inv = 1 / r_s;

    // gradients set zero
    float3x4 gradients = 0;

    gradients._m01_m11_m21 += r_s_inv * invDm[tetId]._m00 * F._m00_m10_m20;
    gradients._m01_m11_m21 += r_s_inv * invDm[tetId]._m01 * F._m01_m11_m21;
    gradients._m01_m11_m21 += r_s_inv * invDm[tetId]._m02 * F._m02_m12_m22;
                                    
    gradients._m02_m12_m22 += r_s_inv * invDm[tetId]._m10 * F._m00_m10_m20;
    gradients._m02_m12_m22 += r_s_inv * invDm[tetId]._m11 * F._m01_m11_m21;
    gradients._m02_m12_m22 += r_s_inv * invDm[tetId]._m12 * F._m02_m12_m22;
                                    
    gradients._m03_m13_m23 += r_s_inv * invDm[tetId]._m20 * F._m00_m10_m20;
    gradients._m03_m13_m23 += r_s_inv * invDm[tetId]._m21 * F._m01_m11_m21;
    gradients._m03_m13_m23 += r_s_inv * invDm[tetId]._m22 * F._m02_m12_m22;

    gradients._m00_m10_m20 = -gradients._m01_m11_m21 - gradients._m02_m12_m22 - gradients._m03_m13_m23;


    ApplyToElement(tetId, C, compliance, gradients);

    
    float gamma = 1.0 + mu / lambda;
    compliance = 1.0 / lambda;
    F = GetDeformationGradient(tetId);
    C = determinant(F) - gamma;

    float3 Fc0 = F._m00_m10_m20;
    float3 Fc1 = F._m01_m11_m21;
    float3 Fc2 = F._m02_m12_m22;
    float3x3 dF = float3x3(cross(Fc1, Fc2), cross(Fc2, Fc0), cross(Fc0, Fc1));

    gradients = 0;

    gradients._m01_m11_m21 += invDm[tetId]._m00 * dF._m00_m10_m20;
    gradients._m01_m11_m21 += invDm[tetId]._m01 * dF._m01_m11_m21;
    gradients._m01_m11_m21 += invDm[tetId]._m02 * dF._m02_m12_m22;

    gradients._m02_m12_m22 += invDm[tetId]._m10 * dF._m00_m10_m20;
    gradients._m02_m12_m22 += invDm[tetId]._m11 * dF._m01_m11_m21;
    gradients._m02_m12_m22 += invDm[tetId]._m12 * dF._m02_m12_m22;

    gradients._m03_m13_m23 += invDm[tetId]._m20 * dF._m00_m10_m20;
    gradients._m03_m13_m23 += invDm[tetId]._m21 * dF._m01_m11_m21;
    gradients._m03_m13_m23 += invDm[tetId]._m22 * dF._m02_m12_m22;

    gradients._m00_m10_m20 = -gradients._m01_m11_m21 - gradients._m02_m12_m22 - gradients._m03_m13_m23;

    ApplyToElement(tetId, C, compliance, gradients);
}