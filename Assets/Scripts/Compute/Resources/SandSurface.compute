#pragma kernel HeightIntergration
#pragma kernel CacheCopy
#pragma kernel UpdateVelocity
#pragma kernel ApplyFriction
#pragma kernel UpdateTexture
#pragma kernel Collision

#include "../settings.hlsl"
static const int NumThreads = 64;
 
RWTexture2D<float4> sandHeightMap;
RWTexture2D<float4> sandNormalMap;
RWTexture2D<float4> terrainNormalMap;

RWStructuredBuffer<REAL> heights;
RWStructuredBuffer<REAL> heights_cache;
RWStructuredBuffer<REAL> u;
RWStructuredBuffer<REAL> v;

Texture2D<float4> terrainHeightMap;
StructuredBuffer<REAL> terrainHeights;

struct Contact
{
    int index;
    REAL3 p;
    REAL3 velocity;
    REAL penetration;
};

RWStructuredBuffer<Contact> contacts;

// Settings
const float dt;
const float gravity;
const float mu;
const float spacing;
const uint numX;
const uint numZ;
const float maxHeight;

REAL terrainHeight(int index)
{
    //Check boundary
    uint i = index / numZ;
    uint j = index % numZ;

    //i = max(0, min(i, numX - 1));
    i = clamp(i, 0, numX - 1);
    j = clamp(j, 0, numZ - 1);

    index = i * numZ + j;

    return terrainHeights[index];
}

REAL height(int index)
{
    //Check boundary
    uint i = index / numZ;
    uint j = index % numZ;

    //i = max(0, min(i, numX - 1));
    i = clamp(i, 0, numX - 1);
    j = clamp(j, 0, numZ - 1);

    index = i * numZ + j;

    return heights[index];
}

REAL U(int i, int j)
{
    // boundary vel should be zero
    if(i <= 0 || i > numX - 1 || j <= 0 || j > numZ - 1)
        return 0;

    int index = i * numZ + j;

    return u[index];
}
REAL V(int i, int j)
{
    // boundary vel should be zero
    if(i <= 0 || i > numX - 1 || j <= 0 || j > numZ - 1)
        return 0;
    int index = i * numZ + j;
    return v[index];
}
[numthreads(NumThreads, 1, 1)]
void HeightIntergration (uint3 id : SV_DispatchThreadID)
{
    uint i = id.x / numZ;
    uint j = id.x % numZ;

    // if index out of range or on boundary
    if(id.x >= numX * numZ)
        return;

	uint center = id.x;
    uint left = id.x - numZ;
    uint right = id.x + numZ;
    uint bottom = id.x - 1;
    uint top = id.x + 1;

    REAL g = abs(gravity);
    REAL h = heights[center];

    // neighbor cell height
    REAL h_n = 0;
    REAL h_avg = 0;

    REAL h_right = (i == numX - 1) ? h : heights[right];
    REAL h_left = (i == 0) ? h : heights[left];
    REAL h_top = (j == numZ - 1) ? h : heights[top];
    REAL h_bottom = (j == 0) ? h : heights[bottom];

    // h_right = height(right);
    // h_left = height(left);
    // h_top = height(top);
    // h_bottom = height(bottom);


    //REAL beta = 2.0 * spacing / (gravity * dt);
    //REAL h_adj = max(0, (h_right + h_left + h_top + h_bottom) / 4.0 - beta);

    // right cell is boundary 
    h_n = h_right;
    REAL U0 = max(u[right], 0.0) * h + min(u[right], 0.0) * h_n;

    // left cell is boundary
    h_n = h_left;
    REAL U1 = max(u[center], 0.0) * h_n + min(u[center], 0.0) * h;

    // up cell is boundary
    h_n = h_top;
    REAL U2 = max(v[top], 0.0) * h + min(v[top], 0.0) * h_n;

    // down cell is boundary
    h_n = h_bottom;
    REAL U3 = max(v[center], 0.0) * h_n + min(v[center], 0.0) * h;

    heights[id.x] = max(h - (dt / spacing) * (U0 - U1 + U2 - U3), 0);

    //heights_cache[id.x] = (h - (dt / spacing) * (U0 - U1 + U2 - U3));
}

[numthreads(NumThreads, 1, 1)]
void CacheCopy(uint id : SV_DispatchThreadID)
{
    // if index out of range or on boundary
    if(id.x >= numX * numZ)
        return;

    //heights[id.x] = heights_cache[id.x];
}

[numthreads(NumThreads, 1, 1)]
void UpdateVelocity(uint id : SV_DispatchThreadID)
{
    // if index out of range or on boundary
    if(id.x >= numX * numZ)
        return;

    uint i = id.x / numZ;
    uint j = id.x % numZ;

    
    REAL g = abs(gravity);
    int center = id.x;
    REAL h_C = height(center);
    REAL H_C = terrainHeight(center);

    REAL maxVel = 0.25 * spacing / dt;

    // x-axis part
    if(i > 0)
    {
        int left = center - numZ;
        REAL h_L = height(left);
        REAL H_L = terrainHeight(left);
        REAL u_temp = u[center] - (dt * g / spacing) * (h_C + H_C - h_L - H_L);
        u[center] = clamp(u_temp, -maxVel, maxVel);
    }

    if(j > 0)
    {
        int bottom = center - 1;
        REAL h_B = height(bottom);
        REAL H_B = terrainHeight(bottom);
        REAL v_temp = v[center] - (dt * g / spacing) * (h_C + H_C - h_B - H_B);
        v[center] = clamp(v_temp, -maxVel, maxVel);
    }
}

[numthreads(NumThreads, 1, 1)]
void ApplyFriction(uint id : SV_DispatchThreadID)
{
    // if index out of range or on boundary
    if(id.x >= numX * numZ)
        return;
        
    uint i = id.x / numZ;
    uint j = id.x % numZ;

    int center = id.x;
    int right = (i + 1) * numZ + j;
    int top = i * numZ + j + 1;

    REAL g = abs(gravity);
    REAL friction = mu * g;

    if(i == 0)
    {
        u[center] = 0;
    }
    else
    {
        REAL U = u[center] + (V(i, j) + V(i, j + 1) + V(i - 1, j + 1) + V(i - 1, j)) / 4;
        REAL correction = (abs(U) < EPSILON) ? 0 : max((abs(U) - dt * friction) / abs(U), 0);
        u[center] *= correction;
    }
  
    if(j == 0)
    {
        v[center] = 0;
    }
    else
    {
        REAL V = v[center] + (U(i, j) + U(i + 1, j) + U(i + 1, j - 1) + U(i, j - 1)) / 4;
        REAL correction = (abs(V) < EPSILON) ? 0 : max((abs(V) - dt * friction) / abs(V), 0);
        v[center] *= correction;
    }
}

[numthreads(8, 8, 1)]
void UpdateTexture(uint3 id : SV_DispatchThreadID)
{
    uint index = id.x * numZ + id.y;
    if(index >= numX * numZ)
        return;

    REAL H = terrainHeight(index);
    sandHeightMap[id.xy] = heights[index] < EPSILON ? 0 : (heights[index] + H) / maxHeight;
    //sandHeightMap[id.xy] = (heights[index] + H) / maxHeight;
    return;

    uint i = id.x; 
    uint j = id.y;

    if(i >= numX - 1 || j >= numZ - 1)
        return;

    sandNormalMap[id.xy] = REAL4(0.5, 0.5, 1.0, 1.0);

    uint left = index;
    uint right = index + numZ;
    uint bottom = index;
    uint top = index + 1;

    REAL x = -(heights[right] - heights[left]) / (2 * spacing);
    REAL y = -(heights[top] - heights[bottom]) / (2 * spacing);
    x += -(terrainHeight(right) - terrainHeight(left)) / (2 * spacing);
    y += -(terrainHeight(top) - terrainHeight(bottom)) / (2 * spacing);
    REAL3 normal = normalize(REAL3(x, y, 1));

    //sandNormalMap[id.xy] = REAL4(0.5 + 0.5 * normal, 1);


    x = -(terrainHeight(right) - terrainHeight(left)) / (2 * spacing);
    y = -(terrainHeight(top) - terrainHeight(bottom)) / (2 * spacing);
    normal = normalize(REAL3(x,y,1));

    //terrainNormalMap[id.xy] = REAL4(0.5 + 0.5 * normal, 1); 
}

[numthreads(NumThreads, 1, 1)]
void Collision(uint id : SV_DispatchThreadID)
{
    int index = contacts[id.x].index;
    REAL h = min(heights[index], contacts[id.x].penetration);
    REAL hSand = max(heights[index] - h, 0);
    REAL H = h + hSand;
 
    uint i = index / numZ;
    uint j = index % numZ;

    REAL S[4];
    
    S[0] = (i == numX - 1) ? 0 : 1;
    S[1] = (i == 0) ? 0 : 1;
    S[2] = (j == numZ - 1) ? 0 : 1;
    S[3] = (j == 0) ? 0 : 1;

    REAL SS = S[0] + S[1] + S[2] + S[3];

    uint center = index;
    uint right = index + numZ;
    uint top = index + 1;


    REAL u_right = (i == numX - 1) ? 0 : u[right];
    REAL v_top = (j == numZ - 1) ? 0 : v[top];

    REAL3 nS = h * contacts[id.x].velocity;
    REAL nSand1 = hSand * u_right;
    REAL nSand2 = hSand * u[center]; 
    REAL nSand3 = hSand * v_top; 
    REAL nSand4 = hSand * v[center];

    REAL w = nS.y / SS;
     
    REAL ur_temp = u_right + (nS.x + nSand1 + w) / H;
    REAL uc_temp = u[center] + (nS.x + nSand2 + w) / H;
    REAL vt_temp = v_top + (nS.z + nSand3 + w) / H;
    REAL vc_temp = v[center] + (nS.z + nSand4 + w) / H;

    REAL maxVel = 0.5 * spacing / dt;

    u[right] = (i == numX - 1) ? 0 : clamp(ur_temp, -maxVel, maxVel);
    u[center] = (i == 0) ? 0 : clamp(uc_temp, -maxVel, maxVel);
    v[top] = (j == numZ - 1) ? 0 : clamp(vt_temp, -maxVel, maxVel);
    v[center] = (j == 0) ? 0 : clamp(vc_temp, -maxVel, maxVel);
}