#pragma kernel TerrainCollision
#pragma kernel DataCopy
#pragma kernel CollisionSolve
#pragma kernel CollisionVelocitySolve

#include <Assets/Scripts/Compute/settings.hlsl>
#include <Assets/Scripts/Compute/util.hlsl>
#include <Assets/Scripts/Compute/bodyStructs.hlsl>

struct Collision{
    uint valid;
    REAL3 q;
    REAL3 pos;
    REAL3 N;
    REAL3 T;
    REAL3 B;
    REAL3 fn;
    REAL vn_;
};
RWStructuredBuffer<Collision> collisions; 
AppendStructuredBuffer<Collision> appendCollisions;
ConsumeStructuredBuffer<Collision> consumeCollisions;
StructuredBuffer<float4> frictionCoef;

// Softbody r/w position and velocity
//RWStructuredBuffer<REAL3> pos;
//RWStructuredBuffer<REAL3> vel;
//
//// Softbody readonly
//StructuredBuffer<REAL3> prevPos;
//StructuredBuffer<REAL> invMass;

Texture2D<half4> _TerrainHeightMap;
SamplerState vertex_linear_clamp_sampler;

Texture2D<half4> _TerrainNormalMap;
SamplerState sampler_TerrainNormalMap;
uint verticesNum;

const float dt;
const float3 terrainOrigin;
const float3 terrainSize;
const uint numCollisions;

[numthreads(128, 1, 1)]
void TerrainCollision(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;

    if(i >= verticesNum)
        return;

    REAL3 position = particles[i].pos;
    REAL3 velocity = particles[i].vel;
    
    // Predicted position after update
    REAL3 predPos = position + velocity * dt;
    predPos = position;
    //Check pos is in the bound of terrain;

    REAL3 terrainMin = terrainOrigin;
    REAL3 terrainMax = terrainOrigin + terrainSize;
    
    bool xIsInside = predPos.x >= terrainMin.x && predPos.x <= terrainMax.x;
    bool zIsInside = predPos.z >= terrainMin.z && predPos.z <= terrainMax.z;

    // If either x/z coordinate out side
    if(!xIsInside || !zIsInside)
        return;
    
    float2 uv = float2((predPos.x - terrainMin.x) / terrainSize.x, (predPos.z - terrainMin.z) / terrainSize.z);
    
    // Project y coordinate
    float hm = _TerrainHeightMap.SampleLevel(vertex_linear_clamp_sampler, uv, 0).r;
    float height = hm * terrainSize.y * 2;
    if(predPos.y > height)
        return;

    // Calculate contact normal
    REAL3 normal =_TerrainNormalMap.SampleLevel(vertex_linear_clamp_sampler, uv, 0) * 2 - 1;

    // Construct collision data
    Collision newCollision = (Collision)0;
    newCollision.valid = i;
    newCollision.q = REAL3(predPos.x, height, predPos.z);
    newCollision.pos = position;
    newCollision.N = normal;
    newCollision.T = OrthogonalVector(newCollision.N);
    newCollision.B = cross(newCollision.N, newCollision.T);

    appendCollisions.Append(newCollision);

}

[numthreads(128, 1, 1)]
void DataCopy(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(i >= numCollisions)
        return;

    //collisions[i] = consumeCollisions.Consume();
}

[numthreads(128, 1, 1)]
void CollisionSolve(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;

    if(i >= numCollisions)
        return;

    Collision C = collisions[i];
    uint index = C.valid;

    REAL3 position = particles[index].pos;
    REAL3 prevPosition = particles[index].prevPos;
    REAL3 velocity = particles[index].vel;
    REAL invMass = particles[index].invMass;

    collisions[i].vn_ = dot(C.N, velocity);

    // Check if collision still exist
    REAL penetration = dot(position - C.q, C.N);
    if(penetration >= EPSILON)
        return;

    REAL h2 = dt * dt;
    REAL alpha = 0;
    REAL w1 = invMass;
    REAL w2 = 0;

    // Normal
    REAL dlambda = -penetration / (w1 + w2 + alpha);
    REAL3 p = dlambda * C.N;
    position += p * w1;

    collisions[i].fn = p / h2;

    REAL3 dp = position - prevPosition;
    REAL4 coef = frictionCoef[i];

    // Tangent direction
    REAL dp_t = dot(dp, C.T);
    REAL C_T = abs(dp_t);
    //ft = REAL3.zero;
    if (C_T > EPSILON)
    {
        REAL dlambda_t = -dp_t / (w1 + w2 + alpha);
        dlambda_t = max(-coef[2] * dlambda, min(dlambda_t, coef[0] * dlambda));

        REAL3 p_t = dlambda_t * C.T;
        position += p_t * w1;
    }

    // Bitangent direction
    REAL dp_b = dot(dp, C.B);
    REAL C_B = abs(dp_b);
    //ft = REAL3.zero;
    if (C_B > EPSILON)
    {
        REAL dlambda_b = -dp_b / (w1 + w2 + alpha);
        dlambda_b = max(-coef[3] * dlambda, min(dlambda_b, coef[1] * dlambda));

        REAL3 p_b = dlambda_b * C.B;
        position += p_b * w1;
    }

    particles[index].pos = position;
}

[numthreads(128, 1, 1)]
void CollisionVelocitySolve(uint3 id : SV_DispatchThreadID)
{
    uint i = id.x;
    if(i >= numCollisions)
        return;

    Collision C = collisions[i];
    uint index = C.valid;

    //REAL3 position = particles[index].pos;
    REAL3 velocity = particles[index].vel;

    REAL3 v = velocity;
    REAL vn = dot(C.N, v);
    REAL normalImpulse = dt * length(C.fn);

    if (normalImpulse < EPSILON)
        return;

    REAL4 coef = frictionCoef[i];

    // tangent
    REAL vt = dot(v, C.T); 
    REAL tangentCoef = (vt > 0) ? coef[0] : coef[2];
    REAL3 dvt = -sign(vt) * min(normalImpulse * tangentCoef, abs(vt)) * C.T;
    velocity += dvt;
    
    // bitangent
    REAL vb = dot(v, C.B);
    REAL bitangentCoef = (vb > 0) ? coef[1] : coef[3];
    REAL3 dvb = -sign(vb) * min(normalImpulse * bitangentCoef, abs(vb)) * C.B;
    velocity += dvb;

    // normal
    REAL restitutionCoef = (abs(vn) <= 2.0 * 9.81 * dt) ? 0.0 : 1.0;
    REAL3 dvn = C.N * (-vn + max(0.0, -restitutionCoef * C.vn_));
    velocity += dvn;

    particles[index].vel = velocity;
}