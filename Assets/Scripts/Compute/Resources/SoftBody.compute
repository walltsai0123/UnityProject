// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel PreSolve
#pragma kernel SolveElement
#pragma kernel PostSolve
#pragma kernel UpdateMesh
#pragma kernel UpdateVisualMesh

#include <Assets/Scripts/Compute/settings.hlsl>
#include <Assets/Scripts/Compute/system.hlsl>
#include <Assets/Scripts/Compute/util.hlsl>
#include <Assets/Scripts/Compute/bodyStructs.hlsl>

//RWStructuredBuffer<SoftBodyParticle> particles;
//RWStructuredBuffer<REAL3> pos;
//RWStructuredBuffer<REAL3> prevPos;
//RWStructuredBuffer<REAL3> vel;
//StructuredBuffer<REAL> invMass;

RWByteAddressBuffer meshVertices;

StructuredBuffer<int4> tets;
StructuredBuffer<REAL> restVolumes;
StructuredBuffer<REAL3x3> invDm;
StructuredBuffer<int> elements;
StructuredBuffer<REAL4> skinningInfo;

//uint verticesNum;
uint tetsNum;
uint passSize;
uint firstConstraint;

//const float dt;
const float mu;
const float lambda;
const float3 gravity;
const uint vertexStride;
const uint vertexOffset;
const uint tetOffset;

inline REAL3x3 GetDeformationGradient(uint tetId)
{
    int id0 = tets[tetId].x;
    int id1 = tets[tetId].y;
    int id2 = tets[tetId].z;
    int id3 = tets[tetId].w;

    REAL3 pos0 = particles[id0].pos;
    REAL3 pos1 = particles[id1].pos;
    REAL3 pos2 = particles[id2].pos;
    REAL3 pos3 = particles[id3].pos;

    
    REAL3x3 Ds = 0;
    Ds._m00_m10_m20 = pos1 - pos0;
    Ds._m01_m11_m21 = pos2 - pos0;
    Ds._m02_m12_m22 = pos3 - pos0;

    return mul(Ds, invDm[tetId]);
}

inline void ApplyToElement(uint i, REAL C, REAL compliance, REAL3x4 gradients)
{
    if (abs(C) < EPSILON)
        return;

    int id0 = tets[i].x;
    int id1 = tets[i].y;
    int id2 = tets[i].z;
    int id3 = tets[i].w;

    REAL weight = 0.0;
    weight += dot(gradients._m00_m10_m20, gradients._m00_m10_m20) * particles[id0].invMass;
    weight += dot(gradients._m01_m11_m21, gradients._m01_m11_m21) * particles[id1].invMass;
    weight += dot(gradients._m02_m12_m22, gradients._m02_m12_m22) * particles[id2].invMass;
    weight += dot(gradients._m03_m13_m23, gradients._m03_m13_m23) * particles[id3].invMass;

    if (weight < EPSILON)
        return;

    REAL h2 = dt * dt;
    REAL alpha = compliance / h2 / restVolumes[i];
    REAL dlambda = -C / (weight + alpha);

    //pos[id0] += dlambda * invMass0 * gradients._m00_m10_m20;
    //pos[id1] += dlambda * invMass1 * gradients._m01_m11_m21;
    //pos[id2] += dlambda * invMass2 * gradients._m02_m12_m22;
    //pos[id3] += dlambda * invMass3 * gradients._m03_m13_m23;

    particles[id0].pos += dlambda * particles[id0].invMass * gradients._m00_m10_m20;
    particles[id1].pos += dlambda * particles[id1].invMass * gradients._m01_m11_m21;
    particles[id2].pos += dlambda * particles[id2].invMass * gradients._m02_m12_m22;
    particles[id3].pos += dlambda * particles[id3].invMass * gradients._m03_m13_m23;
}
inline REAL SolveDeviatoric(uint i, out REAL3x4 gradient)
{
    gradient = 0;
    REAL3x3 F = GetDeformationGradient(i);
    REAL3 f1 = F._m00_m10_m20;
    REAL3 f2 = F._m01_m11_m21;
    REAL3 f3 = F._m02_m12_m22;
    REAL r_s = sqrt(dot(f1, f1) + dot(f2, f2) + dot(f3, f3));

    REAL C = r_s;

    REAL r_s_inv = 1.0 / r_s;

    REAL3x3 QT = transpose(invDm[i]);
    REAL3x3 dC_D = r_s_inv * mul(F, QT);

    REAL3 grad1_D = dC_D._m00_m10_m20;
    REAL3 grad2_D = dC_D._m01_m11_m21;
    REAL3 grad3_D = dC_D._m02_m12_m22;
    REAL3 grad0_D = -grad1_D - grad2_D - grad3_D;

    // gradients set zero
    REAL3x4 gradients_d = 0;
    gradients_d._m00_m10_m20 = grad0_D;
    gradients_d._m01_m11_m21 = grad1_D;
    gradients_d._m02_m12_m22 = grad2_D;
    gradients_d._m03_m13_m23 = grad3_D;

    REAL compliance = 1 / (mu);

    gradient = gradients_d;
    return C;
}
REAL SolveVolumetric(uint i, out REAL3x4 gradient)
{
    gradient = 0;

    REAL gamma = mu / lambda;
    REAL compliance = 1 / (lambda);

    REAL3x3 F = GetDeformationGradient(i);
    
    REAL C = determinant(F) - 1.0 - gamma;

    REAL3 f1 = F._m00_m10_m20;
    REAL3 f2 = F._m01_m11_m21;
    REAL3 f3 = F._m02_m12_m22;

    REAL3x3 QT = transpose(invDm[i]);
    REAL3x3 dF = REAL3x3(cross(f2, f3), cross(f3, f1), cross(f1, f2));
    dF = transpose(dF);
    dF._m00_m10_m20 = cross(f2, f3);
    dF._m01_m11_m21 = cross(f3, f1);
    dF._m02_m12_m22 = cross(f1, f2);
    REAL3x3 dC_V = mul(dF, QT);

    REAL3 grad1_V = dC_V._m00_m10_m20;
    REAL3 grad2_V = dC_V._m01_m11_m21;
    REAL3 grad3_V = dC_V._m02_m12_m22;
    REAL3 grad0_V = -grad1_V - grad2_V - grad3_V;

    // gradients set zero
    REAL3x4 gradients_v = 0;
    gradients_v._m00_m10_m20 = grad0_V;
    gradients_v._m01_m11_m21 = grad1_V;
    gradients_v._m02_m12_m22 = grad2_V;
    gradients_v._m03_m13_m23 = grad3_V;
    gradient = gradients_v;

    return C;

    //ApplyToElement(i, C, compliance, gradients_v);
}
[numthreads(64,1,1)]
void PreSolve(uint3 dispatchID : SV_DispatchThreadID)
{
    uint i = dispatchID.x;

    if(i >= verticesNum)
        return;
    if(particles[i].invMass == 0)
        return;

    //vel[i] += dt * gravity;
    //prevPos[i] = pos[i];
    //pos[i] += dt * vel[i];

    particles[i].vel += dt * gravity;
    particles[i].prevPos = particles[i].pos;
    particles[i].pos += dt * particles[i].vel;
}

[numthreads(64,1,1)]
void SolveElement(uint3 dispatchID : SV_DispatchThreadID)
{
    if(dispatchID.x >= passSize)
        return;

    uint tetId = elements[dispatchID.x + firstConstraint];

    REAL C_D, C_V;
    REAL3x4 gradients_D, gradients_V;

    C_D = SolveDeviatoric(tetId, gradients_D);
    C_V = SolveVolumetric(tetId, gradients_V);

    if(abs(C_D) >= EPSILON && abs(C_V) >= EPSILON)
    {
        // vertices index
        int id0 = tets[tetId].x;
        int id1 = tets[tetId].y;
        int id2 = tets[tetId].z;
        int id3 = tets[tetId].w;

        REAL invMass0 =  particles[id0].invMass;
        REAL invMass1 =  particles[id1].invMass;
        REAL invMass2 =  particles[id2].invMass;
        REAL invMass3 =  particles[id3].invMass;

        REAL compliance_D = 1 / (mu * restVolumes[tetId]);
        REAL compliance_V = 1 / (lambda * restVolumes[tetId]);
        REAL2x2 alpha = {
            compliance_D, 0.0,
            0.0, compliance_V
        };
        alpha /= dt * dt;

        REAL3 grad0_D = gradients_D._m00_m10_m20;
        REAL3 grad1_D = gradients_D._m01_m11_m21;
        REAL3 grad2_D = gradients_D._m02_m12_m22;
        REAL3 grad3_D = gradients_D._m03_m13_m23;

        REAL3 grad0_V = gradients_V._m00_m10_m20;
        REAL3 grad1_V = gradients_V._m01_m11_m21;
        REAL3 grad2_V = gradients_V._m02_m12_m22;
        REAL3 grad3_V = gradients_V._m03_m13_m23;

        REAL2x2 A = 0;

        A._m00 += dot(grad0_D, grad0_D) * invMass0;
        A._m00 += dot(grad1_D, grad1_D) * invMass1;
        A._m00 += dot(grad2_D, grad2_D) * invMass2;
        A._m00 += dot(grad3_D, grad3_D) * invMass3;
        
        A._m01 += dot(grad0_D, grad0_V) * invMass0;
        A._m01 += dot(grad1_D, grad1_V) * invMass1;
        A._m01 += dot(grad2_D, grad2_V) * invMass2;
        A._m01 += dot(grad3_D, grad3_V) * invMass3;

        A._m10 = A._m01;

        A._m11 += dot(grad0_V, grad0_V) * invMass0;
        A._m11 += dot(grad1_V, grad1_V) * invMass1;
        A._m11 += dot(grad2_V, grad2_V) * invMass2;
        A._m11 += dot(grad3_V, grad3_V) * invMass3;

        A += alpha;

        REAL2 dlambda = LUSolve(A, REAL2(-C_D, -C_V));

        //pos[id0] += dlambda[0] * invMass0 * grad0_D + dlambda[1] * invMass0 * grad0_V;
        //pos[id1] += dlambda[0] * invMass1 * grad1_D + dlambda[1] * invMass1 * grad1_V;
        //pos[id2] += dlambda[0] * invMass2 * grad2_D + dlambda[1] * invMass2 * grad2_V;
        //pos[id3] += dlambda[0] * invMass3 * grad3_D + dlambda[1] * invMass3 * grad3_V;

        particles[id0].pos += dlambda[0] * invMass0 * grad0_D + dlambda[1] * invMass0 * grad0_V;
        particles[id1].pos += dlambda[0] * invMass1 * grad1_D + dlambda[1] * invMass1 * grad1_V;
        particles[id2].pos += dlambda[0] * invMass2 * grad2_D + dlambda[1] * invMass2 * grad2_V;
        particles[id3].pos += dlambda[0] * invMass3 * grad3_D + dlambda[1] * invMass3 * grad3_V;
    }
    else
    {
        ApplyToElement(tetId, C_D, 1 / mu, gradients_D);
        ApplyToElement(tetId, C_V, 1 / lambda, gradients_V); 
    }
}

[numthreads(64,1,1)]
void PostSolve(uint3 dispatchID : SV_DispatchThreadID)
{
    uint i = dispatchID.x;

    if(i >= verticesNum)
        return;

    if(particles[i].invMass < EPSILON)
        return;

    //pos[i].y = max(pos[i].y, 0);
    //vel[i] = (pos[i] - prevPos[i]) / dt;
    particles[i].vel = (particles[i].pos - particles[i].prevPos) / dt;
}

[numthreads(64,1,1)]
void UpdateMesh(uint3 dispatchID : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint i = dispatchID.x;
    if(i >= verticesNum) 
        return;

    uint address = i * vertexStride / 4;
    uint posId = i + vertexOffset;

    REAL3 position = particles[posId].pos;

    uint3 data;
    data.x = asuint((float)position.x);
    data.y = asuint((float)position.y);
    data.z = asuint((float)position.z);
    meshVertices.Store((address + 0) << 2, data.x);
    meshVertices.Store((address + 1) << 2, data.y);
    meshVertices.Store((address + 2) << 2, data.z);
}

[numthreads(64,1,1)]
void UpdateVisualMesh(uint3 dispatchID : SV_DispatchThreadID, uint3 groupID : SV_GroupID, uint3 groupThreadID : SV_GroupThreadID)
{
    uint i = dispatchID.x;
    if(i >= verticesNum) 
        return;

    uint address = i * vertexStride / 4;
    uint tetNr = (uint)skinningInfo[i][0] + tetOffset;

    REAL b0 = skinningInfo[i][1];
    REAL b1 = skinningInfo[i][2];
    REAL b2 = skinningInfo[i][3];
    REAL b3 = 1 - b0 - b1 - b2;

    int id0 = tets[tetNr].x;
    int id1 = tets[tetNr].y;
    int id2 = tets[tetNr].z;
    int id3 = tets[tetNr].w;

    float3 visPos = 0;
    visPos += particles[id0].pos * b0;
    visPos += particles[id1].pos * b1;
    visPos += particles[id2].pos * b2;
    visPos += particles[id3].pos * b3;

    uint3 data;
    data.x = asuint(visPos.x);
    data.y = asuint(visPos.y);
    data.z = asuint(visPos.z);


    meshVertices.Store((address + 0) << 2, data.x);
    meshVertices.Store((address + 1) << 2, data.y);
    meshVertices.Store((address + 2) << 2, data.z);
}
