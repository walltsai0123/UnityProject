#pragma kernel Attach

#include <Assets/Scripts/Compute/system.hlsl>
#include <Assets/Scripts/Compute/bodyStructs.hlsl>

struct ParticlePos
{
    int i;
    REAL3 pos;
};

RWStructuredBuffer<ParticlePos> particlePositions;
RWStructuredBuffer<RigidBody> rigidBodies;

const int rigidId;
const int numConstraints;

[numthreads(1,1,1)]
void Attach (uint3 id : SV_DispatchThreadID)
{
    RigidBody bodyData = rigidBodies[rigidId];
    for(int i = 0; i < numConstraints; ++i)
    {
        ParticlePos pPos = particlePositions[i];
        SoftBodyParticle sp = particles[pPos.i];

        REAL3 R1 = 0;
        REAL3 R2 = rotate_vector(pPos.pos, bodyData.rotation);
        REAL3 dr = (particles[pPos.i].pos + R1) - (bodyData.position + R2);
        REAL C = length(dr);

        if (C < EPSILON)
            continue;

        REAL3 n = normalize(dr);
        REAL3x3 I2Inv = mul(quaternion_to_3x3matrix(bodyData.rotation), mul(bodyData.IBodyInv, quaternion_to_3x3matrix(q_conj(bodyData.rotation))));
        REAL3 r2xn = cross(R2, n);

        REAL w1 = particles[pPos.i].invMass;
        REAL w2 = bodyData.invMass + mul(r2xn, mul(I2Inv, r2xn));
        REAL alpha = 0.0f;
        REAL dlambda = -C / (w1 + w2 + alpha);
        REAL3 p = dlambda * n;

        particles[pPos.i].pos += p * w1;
        bodyData.position -= p * w2;

        REAL3 r2xp = mul(I2Inv, cross(R2, p));
        quaternion Q2 = bodyData.rotation - qmul(quaternion(0.5 * float4((float3)r2xp, 0)), bodyData.rotation);

        bodyData.rotation = normalize(Q2);
    }
    rigidBodies[rigidId] = bodyData; 
}
